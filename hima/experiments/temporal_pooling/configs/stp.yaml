_type_: stp.synthetic_sequences
project: stp.fast_weights
log: True    # wandb logging, use 'dry' for dummy do-nothing logging to test metrics collection

seed: 42
iterate:
  epochs: 20
  sequences: [5, 1]
  elements: 20

data:
  _base_: $_base.dataset.synthetic_sequences.general
  alphabet_size: 200
  encoder:
    _base_: $_base.encoder.random.fixed_sds
    sds: [500, 10]

model: models.unbounded_attraction_with_force_and_sp

models:
  unbounded_attraction_with_sp:
    api_block: ___
    pipeline:
      - ___.input -> gen.output
      - gen.output -> sp0.feedforward
      - sp0.compute
      - tm1.predict
      - tm1.predicted_cells -> sp1.feedforward
      - repeat: 10
        pipeline:
          - sp1.compute
          - sp1.output -> feedforward
      # activate + predict by TM2
      - sp1.feedforward -> tm2.feedforward
      - tm2.set_active_columns
      - tm2.predict
      - tm2.set_predicted_cells
      # correct TM1 predicted cells
      - tm2.predicted_cells -> tm1.predicted_cells
      - tm1.set_predicted_cells
      # activate feedforward
      - sp0.output -> tm1.feedforward
      - tm1.activate
      # learn TM2
      - tm1.active_cells -> tm2.feedforward
      - tm2.activate
      - tm1.correctly_predicted_cells -> ___.output
  unbounded_attraction_with_force_and_sp:
    api_block: ___
    pipeline:
      - ___.input -> gen.output
      - gen.output -> sp0.feedforward
      - sp0.compute
      - tm1.predict
      # concat with tm predictions forced const SDR
      - tm1.predicted_cells -> concat.feedforward_1
      - tm1.predicted_cells -> concat.feedforward_2
      - repeat: 10
        pipeline:
          - concat.compute
          - concat.output -> sp1.feedforward
          - sp1.compute
          # only the 2nd part of concat vector is changed, the 1st part is kept unchanged
          - sp1.output -> concat.feedforward_2
#      - tm2.reset
      # activate + predict by TM2
      - concat.feedforward_2 -> tm2.feedforward
      - tm2.set_active_columns
      - tm2.predict
      - tm2.set_predicted_cells
      # correct TM1 predicted cells
      - tm2.predicted_cells -> tm1.predicted_cells
      - tm1.set_predicted_cells
      # activate feedforward
      - sp0.output -> tm1.feedforward
      - tm1.activate
      # learn TM2
      - tm1.active_cells -> tm2.feedforward
      - tm2.activate
      - tm1.correctly_predicted_cells -> ___.output
  unbounded_attraction:
    api_block: ___
    pipeline:
      - ___.input -> gen.output
      - tm1.predict
      - tm1.predicted_cells -> sp1.feedforward
      - repeat: 5
        pipeline:
          - sp1.compute
          - sp1.output -> feedforward
      # activate + predict by TM2
      - sp1.feedforward -> tm2.feedforward
      - tm2.set_active_columns
      - tm2.predict
      - tm2.set_predicted_cells
      # correct TM1 predicted cells
      - tm2.predicted_cells -> tm1.predicted_cells
      - tm1.set_predicted_cells
      # activate feedforward
      - gen.output -> tm1.feedforward
      - tm1.activate
      # learn TM2
      - tm1.active_cells -> tm2.feedforward
      - tm2.activate
      - tm1.correctly_predicted_cells -> ___.output
  unbounded_attraction_with_force:
    api_block: ___
    pipeline:
      - ___.input -> gen.output
      - tm1.predict
      # concat with tm predictions forced const SDR
      - tm1.predicted_cells -> concat.feedforward_1
      - tm1.predicted_cells -> concat.feedforward_2
      - repeat: 5
        pipeline:
          - concat.compute
          - concat.output -> sp1.feedforward
          - sp1.compute
          # only the 2nd part of concat vector is changed, the 1st part is kept unchanged
          - sp1.output -> concat.feedforward_2
#      - tm2.reset
      # activate + predict by TM2
      - concat.feedforward_2 -> tm2.feedforward
      - tm2.set_active_columns
      - tm2.predict
      - tm2.set_predicted_cells
      # correct TM1 predicted cells
      - tm2.predicted_cells -> tm1.predicted_cells
      - tm1.set_predicted_cells
      # activate feedforward
      - gen.output -> tm1.feedforward
      - tm1.activate
      # learn TM2
      - tm1.active_cells -> tm2.feedforward
      - tm2.activate
      - tm1.correctly_predicted_cells -> ___.output
  hid_state_attraction_with_force_and_feedback:
    api_block: ___
    pipeline:
      - ___.input -> gen.output
      - gen.output -> tm1.feedforward
      - tm1.predict
      # concat with tm predictions forced const SDR
      - tm1.predicted_cells -> concat.feedforward_1
      - tm1.predicted_cells -> concat.feedforward_2
#      - sp1.switch_polarity
      - repeat: 5
        pipeline:
          - concat.compute
          - concat.output -> sp1.feedforward
          - sp1.compute
          # only the 2nd part of concat vector is changed, the 1st part is kept unchanged
          - sp1.output -> concat.feedforward_2
      - concat.feedforward_2 -> tm1.predicted_cells
      - tm1.set_predicted_cells
      - tm1.activate
      - tm1.active_cells -> sp1.feedback
#      - sp1.switch_polarity
      - sp1.compute_feedback
      - tm1.correctly_predicted_cells -> ___.output
  hid_state_attraction_feedback:
    api_block: ___
    pipeline:
      - ___.input -> gen.output
      - gen.output -> tm1.feedforward
      - tm1.predict
      - tm1.predicted_cells -> sp1.feedforward
#      - sp1.switch_polarity
      - repeat: 5
        pipeline:
          - sp1.compute
          - sp1.output -> feedforward
      - sp1.output -> tm1.predicted_cells
      - tm1.set_predicted_cells
      - tm1.activate
      - tm1.active_cells -> sp1.feedback
  #    - sp1.switch_polarity
      - sp1.compute_feedback
      - tm1.correctly_predicted_cells -> ___.output
  hid_state_attraction:
    api_block: ___
    pipeline:
      - ___.input -> gen.output
      - ???.output -> tm1.feedforward
      - tm1.predict
      - tm1.predicted_cells -> sp1.feedforward
      - repeat: 3
        pipeline:
          - sp1.compute
          - sp1.output -> feedforward
      - sp1.output -> tm1.predicted_cells
      - tm1.set_predicted_cells
      - tm1.activate
      - ???.active_cells -> ___.output
  hid_state_attraction_with_force:
    api_block: ___
    pipeline:
      - ___.input -> gen.output
      - ???.output -> tm1.feedforward
      - tm1.predict
      # concat with tm predictions forced const SDR
      - tm1.predicted_cells -> concat.feedforward_1
      - tm1.predicted_cells -> concat.feedforward_2
      - repeat: 3
        pipeline:
          - concat.compute
          - concat.output -> sp1.feedforward
          - sp1.compute
          # only the 2nd part of concat vector is changed, the 1st part is kept unchanged
          - sp1.output -> concat.feedforward_2
      - sp1.output -> tm1.predicted_cells
      - tm1.set_predicted_cells
      - tm1.activate
      - ???.active_cells -> ___.output
  tm_sp:
    api_block: ___
    pipeline:
      - ___.input -> gen.output
      - gen.output -> sp0.feedforward
      - sp0.compute
      - sp0.output -> tm1.feedforward
      - tm1.predict
      - tm1.set_predicted_cells
      - tm1.activate
      - tm1.correctly_predicted_cells -> ___.output
  tm_predictions:
    api_block: ___
    pipeline:
      - ___.input -> gen.output
      - gen.output -> tm1.feedforward
      - tm1.predict
      - tm1.set_predicted_cells
      - tm1.activate
      - tm1.correctly_predicted_cells -> ___.output

blocks:
  ___:
    _type_: block.storage
    input_sds: ???
    output_sds: ???
  gen:
    _type_: block.storage
  concat:
    _type_: block.concatenator
  sp0:
    _base_: $_base.custom_sp.default
    sp_type: vectorized
    output_sds: [500, 10]
    initial_rf_sparsity: 0.25
    max_rf_sparsity: 0.08
    max_rf_to_input_ratio: 0.8
    learning_rate_inc: 0.1
    learning_rate_dec: 0.01
    newborn_pruning_cycle: 0.1
    newborn_pruning_stages: 10
    track_feedforward_sparsity: False
  sp1:
    _base_: $_base.custom_sp.default
    sp_type: vectorized
    output_sds: ??? #[500, 10]
    initial_rf_sparsity: 0.05
    max_rf_sparsity: 0.08
    max_rf_to_input_ratio: 0.85
    learning_rate_inc: 0.01
    learning_rate_dec: 0.001
    newborn_pruning_cycle: 0.15
    newborn_pruning_stages: 10
    track_feedforward_sparsity: False
  tm1:
    _base_: tm.default_general_feedback
    seed: ???
    active_cells_sds: ???
    predicted_cells_sds: ???
    cells_per_column: 12
    activation_threshold_basal: .9
    learning_threshold_basal: .7
    activation_threshold_apical: 1
    learning_threshold_apical: 1
    max_synapses_per_segment_basal: -1
    max_segments_per_cell_basal: 64
  tm2:
    _base_: tm.default_general_feedback
    seed: ???
    active_cells_sds: ???
    predicted_cells_sds: ???
    cells_per_column: 1
    activation_threshold_basal: .8
    learning_threshold_basal: .6
    activation_threshold_apical: 1
    learning_threshold_apical: 1
    max_synapses_per_segment_basal: -1
    max_segments_per_cell_basal: 128

stats_and_metrics:
  mae_normalization: no
  symmetrical_similarity: False
  distribution_metrics: pmf
  online_similarity_decay: 1.
  pmf_decay: 1.
  loss_normalization: False
  loss_layer_discount: 0.75

track_streams:
  gen.output:
    - sdr
    - cross.online.el
  sp0.output:
    - sdr
    - cross.online.el
  sp1.output:
    - sdr
    - cross.online.el
  tm1.correctly_predicted_cells:
    - sdr
    - cross.online.el

diff_stats:
  online_el:
    - gen.output/epoch/sim_mx_on_el
    - sp0.output/epoch/sim_mx_on_el
    - sp1.output/epoch/sim_mx_on_el
    - tm1.correctly_predicted_cells/epoch/sim_mx_on_el

log_schedule:
  epoch: 5
  repeat: 5

iterate_setups:
  simple: ...

tm:
  default_general_feedback:
    _type_: tm.general_feedback
